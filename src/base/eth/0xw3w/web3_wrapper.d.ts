import { AbiDecoder } from '../utils';
import { BigNumber } from '../utils/configured_bignumber';
import { BlockParam, BlockWithoutTransactionData, BlockWithTransactionData, CallData, FilterObject, JSONRPCRequestPayload, LogEntry, SupportedProvider, TraceParams, Transaction, TransactionReceipt, TransactionReceiptWithDecodedLogs, TransactionTrace, TxAccessListWithGas, TxData } from '../types';
import { NodeType } from './types';
export declare class Web3Wrapper {
    isZeroExWeb3Wrapper: boolean;
    abiDecoder: AbiDecoder;
    private _provider;
    private readonly _supportedProvider;
    private readonly _callAndTxnDefaults;
    private _jsonRpcRequestId;
    static isAddress(address: string): boolean;
    static toUnitAmount(amount: BigNumber, decimals: number): BigNumber;
    static toBaseUnitAmount(amount: BigNumber | number, decimals: number): BigNumber;
    static toWei(ethAmount: BigNumber): BigNumber;
    private static _assertBlockParam;
    private static _assertBlockParamOrString;
    private static _normalizeTxReceiptStatus;
    constructor(supportedProvider: SupportedProvider, callAndTxnDefaults?: Partial<CallData>);
    getContractDefaults(): Partial<CallData> | undefined;
    getProvider(): SupportedProvider;
    setProvider(supportedProvider: SupportedProvider): void;
    isSenderAddressAvailableAsync(senderAddress: string): Promise<boolean>;
    getNodeVersionAsync(): Promise<string>;
    getNetworkIdAsync(): Promise<number>;
    getChainIdAsync(): Promise<number>;
    getTransactionReceiptIfExistsAsync(txHash: string): Promise<TransactionReceipt | undefined>;
    getTransactionByHashAsync(txHash: string): Promise<Transaction>;
    getBalanceInWeiAsync(owner: string, defaultBlock?: BlockParam): Promise<BigNumber>;
    doesContractExistAtAddressAsync(address: string): Promise<boolean>;
    getContractCodeAsync(address: string, defaultBlock?: BlockParam): Promise<string>;
    getTransactionTraceAsync(txHash: string, traceParams: TraceParams): Promise<TransactionTrace>;
    signMessageAsync(address: string, message: string): Promise<string>;
    signTypedDataAsync(address: string, typedData: any): Promise<string>;
    getBlockNumberAsync(): Promise<number>;
    getAccountNonceAsync(address: string, defaultBlock?: BlockParam): Promise<number>;
    getBlockIfExistsAsync(blockParam: string | BlockParam): Promise<BlockWithoutTransactionData | undefined>;
    getBlockWithTransactionDataAsync(blockParam: string | BlockParam): Promise<BlockWithTransactionData>;
    getBlockTimestampAsync(blockParam: string | BlockParam): Promise<number>;
    getAvailableAddressesAsync(): Promise<string[]>;
    takeSnapshotAsync(): Promise<number>;
    revertSnapshotAsync(snapshotId: number): Promise<boolean>;
    mineBlockAsync(): Promise<void>;
    increaseTimeAsync(timeDelta: number): Promise<number>;
    getLogsAsync(filter: FilterObject): Promise<LogEntry[]>;
    estimateGasAsync(txData: Partial<TxData>): Promise<number>;
    createAccessListAsync(callData: CallData, defaultBlock?: BlockParam): Promise<TxAccessListWithGas>;
    callAsync(callData: CallData, defaultBlock?: BlockParam): Promise<string>;
    sendTransactionAsync(txData: TxData): Promise<string>;
    awaitTransactionMinedAsync(txHash: string, pollingIntervalMs?: number, timeoutMs?: number): Promise<TransactionReceiptWithDecodedLogs>;
    awaitTransactionSuccessAsync(txHash: string, pollingIntervalMs?: number, timeoutMs?: number): Promise<TransactionReceiptWithDecodedLogs>;
    setHeadAsync(blockNumber: number): Promise<void>;
    sendRawPayloadAsync<A>(payload: Partial<JSONRPCRequestPayload>): Promise<A>;
    getNodeTypeAsync(): Promise<NodeType>;
}
//# sourceMappingURL=web3_wrapper.d.ts.map